{"version":3,"sources":["../src/Canvas/index.tsx","../src/Paths/index.tsx","../src/ReactSketchCanvas/index.tsx"],"sourcesContent":["/* eslint-disable react/no-array-index-key */\nimport * as React from \"react\";\nimport { useCallback } from \"react\";\nimport Paths, { SvgPath } from \"../Paths\";\nimport { CanvasPath, ExportImageType, Point } from \"../types\";\n\nconst loadImage = (url: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.addEventListener(\"load\", () => {\n      if (img.width > 0) {\n        resolve(img);\n      }\n      reject(new Error(\"Image not found\"));\n    });\n    img.addEventListener(\"error\", (err) => reject(err));\n    img.src = url;\n    img.setAttribute(\"crossorigin\", \"anonymous\");\n  });\n\nfunction getCanvasWithViewBox(canvas: HTMLDivElement) {\n  const svgCanvas = canvas.firstChild?.cloneNode(true) as SVGElement;\n\n  const width = canvas.offsetWidth;\n  const height = canvas.offsetHeight;\n\n  svgCanvas.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n\n  svgCanvas.setAttribute(\"width\", width.toString());\n  svgCanvas.setAttribute(\"height\", height.toString());\n  return { svgCanvas, width, height };\n}\n\nexport interface CanvasProps {\n  paths: CanvasPath[];\n  isDrawing: boolean;\n  onPointerDown: (point: Point, isEraser?: boolean) => void;\n  onPointerMove: (point: Point) => void;\n  onPointerUp: () => void;\n  className?: string;\n  id?: string;\n  width: string;\n  height: string;\n  canvasColor: string;\n  strokeRed: number;\n  strokeBlue: number;\n  strokeGreen: number;\n  backgroundImage: string;\n  exportWithBackgroundImage: boolean;\n  preserveBackgroundImageAspectRatio: string;\n  allowOnlyPointerType: string;\n  style: React.CSSProperties;\n  svgStyle: React.CSSProperties;\n  invert?: boolean;\n}\n\nexport interface CanvasRef {\n  exportImage: (imageType: ExportImageType) => Promise<string>;\n  exportSvg: () => Promise<string>;\n}\n\nexport const Canvas = React.forwardRef<CanvasRef, CanvasProps>((props, ref) => {\n  const {\n    paths,\n    isDrawing,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp,\n    id = \"react-sketch-canvas\",\n    width = \"100%\",\n    height = \"100%\",\n    className = \"react-sketch-canvas\",\n    canvasColor = \"red\",\n    strokeRed = 255,\n    strokeBlue = 0,\n    strokeGreen = 0,\n    backgroundImage = \"\",\n    exportWithBackgroundImage = false,\n    preserveBackgroundImageAspectRatio = \"none\",\n    allowOnlyPointerType = \"all\",\n    style = {\n      border: \"0.0625rem solid #9c9c9c\",\n      borderRadius: \"0.25rem\",\n    },\n    svgStyle = {},\n    invert = false,\n  } = props;\n\n  const canvasRef = React.useRef<HTMLDivElement>(null);\n\n  // Converts mouse coordinates to relative coordinate based on the absolute position of svg\n  const getCoordinates = useCallback(\n    (pointerEvent: React.PointerEvent<HTMLDivElement>): Point => {\n      const boundingArea = canvasRef.current?.getBoundingClientRect();\n\n      const scrollLeft = window.scrollX ?? 0;\n      const scrollTop = window.scrollY ?? 0;\n\n      if (!boundingArea) {\n        return { x: 0, y: 0 };\n      }\n\n      return {\n        x: pointerEvent.pageX - boundingArea.left - scrollLeft,\n        y: pointerEvent.pageY - boundingArea.top - scrollTop,\n      };\n    },\n    []\n  );\n\n  /* Mouse Handlers - Mouse down, move and up */\n\n  const handlePointerDown = useCallback(\n    (event: React.PointerEvent<HTMLDivElement>): void => {\n      // Allow only chosen pointer type\n\n      if (\n        allowOnlyPointerType !== \"all\" &&\n        event.pointerType !== allowOnlyPointerType\n      ) {\n        return;\n      }\n\n      if (event.pointerType === \"mouse\" && event.button !== 0) return;\n\n      const isEraser =\n        // eslint-disable-next-line no-bitwise\n        event.pointerType === \"pen\" && (event.buttons & 32) === 32;\n      const point = getCoordinates(event);\n\n      onPointerDown(point, isEraser);\n    },\n    [allowOnlyPointerType, getCoordinates, onPointerDown]\n  );\n\n  const handlePointerMove = useCallback(\n    (event: React.PointerEvent<HTMLDivElement>): void => {\n      if (!isDrawing) return;\n\n      // Allow only chosen pointer type\n      if (\n        allowOnlyPointerType !== \"all\" &&\n        event.pointerType !== allowOnlyPointerType\n      ) {\n        return;\n      }\n\n      const point = getCoordinates(event);\n\n      onPointerMove(point);\n    },\n    [allowOnlyPointerType, getCoordinates, isDrawing, onPointerMove]\n  );\n\n  const handlePointerUp = useCallback(\n    (event: React.PointerEvent<HTMLDivElement> | PointerEvent): void => {\n      if (event.pointerType === \"mouse\" && event.button !== 0) return;\n\n      // Allow only chosen pointer type\n      if (\n        allowOnlyPointerType !== \"all\" &&\n        event.pointerType !== allowOnlyPointerType\n      ) {\n        return;\n      }\n\n      onPointerUp();\n    },\n    [allowOnlyPointerType, onPointerUp]\n  );\n\n  /* Mouse Handlers ends */\n\n  React.useImperativeHandle(ref, () => ({\n    exportImage: (imageType: ExportImageType): Promise<string> => {\n      return new Promise<string>((resolve, reject) => {\n        try {\n          const canvas = canvasRef.current;\n\n          if (!canvas) {\n            throw Error(\"Canvas not rendered yet\");\n          }\n\n          const {\n            svgCanvas,\n            width: svgWidth,\n            height: svgHeight,\n          } = getCanvasWithViewBox(canvas);\n          const canvasSketch = `data:image/svg+xml;base64,${btoa(\n            svgCanvas.outerHTML\n          )}`;\n\n          const loadImagePromises = [loadImage(canvasSketch)];\n\n          if (exportWithBackgroundImage && backgroundImage) {\n            try {\n              const img = loadImage(backgroundImage);\n              loadImagePromises.push(img);\n            } catch (error) {\n              // eslint-disable-next-line no-console\n              console.warn(\n                \"exportWithBackgroundImage props is set without a valid background image URL. This option is ignored\"\n              );\n            }\n          }\n\n          Promise.all(loadImagePromises)\n            .then((images) => {\n              const renderCanvas = document.createElement(\"canvas\");\n              renderCanvas.setAttribute(\"width\", svgWidth.toString());\n              renderCanvas.setAttribute(\"height\", svgHeight.toString());\n              const context = renderCanvas.getContext(\"2d\");\n\n              if (!context) {\n                throw Error(\"Canvas not rendered yet\");\n              }\n\n              if (imageType === \"jpeg\" && !exportWithBackgroundImage) {\n                context.fillStyle = canvasColor;\n                context.fillRect(0, 0, svgWidth, svgHeight);\n              }\n\n              images.reverse().forEach((image) => {\n                context.drawImage(image, 0, 0);\n              });\n\n              resolve(renderCanvas.toDataURL(`image/${imageType}`));\n            })\n            .catch((e) => {\n              reject(e);\n            });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    },\n    exportSvg: (): Promise<string> => {\n      return new Promise<string>((resolve, reject) => {\n        try {\n          const canvas = canvasRef.current ?? null;\n\n          if (canvas !== null) {\n            const { svgCanvas } = getCanvasWithViewBox(canvas);\n\n            if (exportWithBackgroundImage) {\n              resolve(svgCanvas.outerHTML);\n              return;\n            }\n\n            svgCanvas.querySelector(`#${id}__background`)?.remove();\n            svgCanvas\n              .querySelector(`#${id}__canvas-background`)\n              ?.setAttribute(\"fill\", canvasColor);\n\n            resolve(svgCanvas.outerHTML);\n          }\n\n          reject(new Error(\"Canvas not loaded\"));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    },\n  }));\n\n  /* Add event listener to Mouse up and Touch up to\nrelease drawing even when point goes out of canvas */\n  React.useEffect(() => {\n    document.addEventListener(\"pointerup\", handlePointerUp);\n    return () => {\n      document.removeEventListener(\"pointerup\", handlePointerUp);\n    };\n  }, [handlePointerUp]);\n\n  const eraserPaths = React.useMemo(\n    () => paths.filter((path) => !path.drawMode),\n    [paths]\n  );\n\n  const pathGroups = React.useMemo(() => {\n    let currentGroup = 0;\n\n    return paths.reduce<CanvasPath[][]>(\n      (arrayGroup, path) => {\n        if (!path.drawMode) {\n          currentGroup += 1;\n          return arrayGroup;\n        }\n\n        if (arrayGroup[currentGroup] === undefined) {\n          // eslint-disable-next-line no-param-reassign\n          arrayGroup[currentGroup] = [];\n        }\n\n        arrayGroup[currentGroup].push(path);\n        return arrayGroup;\n      },\n      [[]]\n    );\n  }, [paths]);\n\n  return (\n    <div\n      role=\"presentation\"\n      ref={canvasRef}\n      className={className}\n      style={{\n        touchAction: \"none\",\n        width,\n        height,\n        ...style,\n      }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <svg\n        version=\"1.1\"\n        baseProfile=\"full\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          ...svgStyle,\n        }}\n        id={id}\n      >\n        <defs>\n          <filter id=\"invert-alpha\">\n            <feColorMatrix\n              type=\"matrix\"\n              colorInterpolationFilters=\"sRGB\"\n              values={`1 0 0 0 ${strokeRed / 255}\n                      0 1 0 0 ${strokeGreen / 255}\n                      0 0 1 0 ${strokeBlue / 255}\n                      0 0 0 -1 1`}\n            />\n          </filter>\n        </defs>\n        <g id={`${id}__eraser-stroke-group`} display=\"none\">\n          <rect\n            id={`${id}__mask-background`}\n            x=\"0\"\n            y=\"0\"\n            width=\"100%\"\n            height=\"100%\"\n            fill=\"white\"\n          />\n          {eraserPaths.map((eraserPath, i) => (\n            <SvgPath\n              key={`${id}__eraser-${i}`}\n              id={`${id}__eraser-${i}`}\n              paths={eraserPath.paths}\n              strokeColor=\"#000000\"\n              strokeWidth={eraserPath.strokeWidth}\n            />\n          ))}\n        </g>\n        <defs>\n          {backgroundImage && (\n            <pattern\n              id={`${id}__background`}\n              x=\"0\"\n              y=\"0\"\n              width=\"100%\"\n              height=\"100%\"\n              patternUnits=\"userSpaceOnUse\"\n            >\n              <image\n                x=\"0\"\n                y=\"0\"\n                width=\"100%\"\n                height=\"100%\"\n                xlinkHref={backgroundImage}\n                preserveAspectRatio={preserveBackgroundImageAspectRatio}\n              />\n            </pattern>\n          )}\n\n          {eraserPaths.map((_, i) => (\n            <mask\n              id={`${id}__eraser-mask-${i}`}\n              key={`${id}__eraser-mask-${i}`}\n              maskUnits=\"userSpaceOnUse\"\n            >\n              <use href={`#${id}__mask-background`} />\n              {Array.from(\n                { length: eraserPaths.length - i },\n                (_i, j) => j + i\n              ).map((k) => (\n                <use\n                  key={k.toString()}\n                  href={`#${id}__eraser-${k.toString()}`}\n                />\n              ))}\n            </mask>\n          ))}\n        </defs>\n        <g id={`${id}__canvas-background-group`}>\n          <rect\n            id={`${id}__canvas-background`}\n            x=\"0\"\n            y=\"0\"\n            width=\"100%\"\n            height=\"100%\"\n            fill={backgroundImage ? `url(#${id}__background)` : canvasColor}\n          />\n        </g>\n        {invert && (\n          <g filter=\"url(#invert-alpha)\">\n            <rect x=\"-1\" y=\"-1\" width=\"200%\" height=\"200%\" fill=\"none\" />\n            {pathGroups.map((pathGroup, i) => (\n              <g\n                id={`${id}__stroke-group-${i}`}\n                key={`${id}__stroke-group-${i}`}\n                mask={`${eraserPaths[i] && `url(#${id}__eraser-mask-${i})`}`}\n              >\n                <Paths\n                  id={`${id}__stroke-group-${i}__paths`}\n                  paths={pathGroup}\n                />\n              </g>\n            ))}\n          </g>\n        )}\n        {invert ||\n          pathGroups.map((pathGroup, i) => (\n            <g\n              id={`${id}__stroke-group-${i}`}\n              key={`${id}__stroke-group-${i}`}\n              mask={`${eraserPaths[i] && `url(#${id}__eraser-mask-${i})`}`}\n            >\n              <Paths id={`${id}__stroke-group-${i}__paths`} paths={pathGroup} />\n            </g>\n          ))}\n      </svg>\n    </div>\n  );\n});\n","/* eslint-disable react/no-array-index-key */\nimport * as React from \"react\";\nimport { CanvasPath, Point } from \"../types\";\n\nexport const line = (pointA: Point, pointB: Point) => {\n  const lengthX = pointB.x - pointA.x;\n  const lengthY = pointB.y - pointA.y;\n\n  return {\n    length: Math.sqrt(lengthX ** 2 + lengthY ** 2),\n    angle: Math.atan2(lengthY, lengthX),\n  };\n};\n\nconst controlPoint = (controlPoints: ControlPoints): [number, number] => {\n  const { current, next, previous, reverse } = controlPoints;\n\n  const p = previous || current;\n  const n = next || current;\n\n  const smoothing = 0.2;\n\n  const o = line(p, n);\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing;\n\n  const x = current.x + Math.cos(angle) * length;\n  const y = current.y + Math.sin(angle) * length;\n\n  return [x, y];\n};\n\nexport const bezierCommand = (point: Point, i: number, a: Point[]): string => {\n  let cpsX: number;\n  let cpsY: number;\n\n  switch (i) {\n    case 0:\n      [cpsX, cpsY] = controlPoint({\n        current: point,\n      });\n      break;\n    case 1:\n      [cpsX, cpsY] = controlPoint({\n        current: a[i - 1],\n        next: point,\n      });\n      break;\n    default:\n      [cpsX, cpsY] = controlPoint({\n        current: a[i - 1],\n        previous: a[i - 2],\n        next: point,\n      });\n      break;\n  }\n\n  const [cpeX, cpeY] = controlPoint({\n    current: point,\n    previous: a[i - 1],\n    next: a[i + 1],\n    reverse: true,\n  });\n\n  return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point.x}, ${point.y}`;\n};\n\nexport type SvgPathProps = {\n  // List of points to create the stroke\n  paths: Point[];\n  // Unique ID\n  id: string;\n  // Width of the stroke\n  strokeWidth: number;\n  // Color of the stroke\n  strokeColor: string;\n  // Bezier command to smoothen the line\n  command?: (point: Point, i: number, a: Point[]) => string;\n};\n\n/**\n * Generate SVG Path tag from the given points\n */\nexport function SvgPath({\n  paths,\n  id,\n  strokeWidth,\n  strokeColor,\n  command = bezierCommand,\n}: SvgPathProps): JSX.Element {\n  if (paths.length === 1) {\n    const { x, y } = paths[0];\n    const radius = strokeWidth / 2;\n\n    return (\n      <circle\n        key={id}\n        id={id}\n        cx={x}\n        cy={y}\n        r={radius}\n        stroke={strokeColor}\n        fill={strokeColor}\n      />\n    );\n  }\n\n  const d = paths.reduce(\n    (acc, point, i, a) =>\n      i === 0 ? `M ${point.x},${point.y}` : `${acc} ${command(point, i, a)}`,\n    \"\"\n  );\n\n  return (\n    <path\n      key={id}\n      id={id}\n      d={d}\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      stroke={strokeColor}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\ntype ControlPoints = {\n  current: Point;\n  previous?: Point;\n  next?: Point;\n  reverse?: boolean;\n};\n\ntype PathProps = {\n  id: string;\n  paths: CanvasPath[];\n};\n\nfunction Paths({ id, paths }: PathProps): JSX.Element {\n  return (\n    <>\n      {paths.map((path: CanvasPath, index: number) => (\n        <SvgPath\n          key={`${id}__${index}`}\n          paths={path.paths}\n          id={`${id}__${index}`}\n          strokeWidth={path.strokeWidth}\n          strokeColor={path.strokeColor}\n          command={bezierCommand}\n        />\n      ))}\n    </>\n  );\n}\n\nexport default Paths;\n","import * as React from \"react\";\nimport { Canvas, CanvasRef } from \"../Canvas\";\nimport { CanvasPath, ExportImageType, Point } from \"../types\";\n\n/* Props validation */\nexport interface ReactSketchCanvasProps {\n  allowOnlyPointerType?: string;\n  backgroundImage?: string;\n  canvasColor?: string;\n  className?: string;\n  eraserWidth?: number;\n  exportWithBackgroundImage?: boolean;\n  height?: string;\n  id?: string;\n  onChange?: (updatedPaths: CanvasPath[]) => void;\n  onStroke?: (path: CanvasPath, isEraser: boolean) => void;\n  preserveBackgroundImageAspectRatio?: string;\n  strokeRed?: number;\n  strokeBlue?: number;\n  strokeGreen?: number;\n  strokeWidth?: number;\n  style?: React.CSSProperties;\n  svgStyle?: React.CSSProperties;\n  width?: string;\n  withTimestamp?: boolean;\n  invert?: boolean;\n}\n\nexport interface ReactSketchCanvasRef {\n  eraseMode: (_erase: boolean) => void;\n  clearCanvas: () => void;\n  undo: () => void;\n  redo: () => void;\n  exportImage: (imageType: ExportImageType) => Promise<string>;\n  exportSvg: () => Promise<string>;\n  exportPaths: () => Promise<CanvasPath[]>;\n  loadPaths: (paths: CanvasPath[]) => void;\n  getSketchingTime: () => Promise<number>;\n  resetCanvas: () => void;\n}\n\nexport const ReactSketchCanvas = React.forwardRef<\n  ReactSketchCanvasRef,\n  ReactSketchCanvasProps\n>((props, ref) => {\n  const {\n    id = \"react-sketch-canvas\",\n    width = \"100%\",\n    height = \"100%\",\n    className = \"\",\n    canvasColor = \"white\",\n    strokeRed = 140,\n    strokeGreen = 6,\n    strokeBlue = 30,\n    backgroundImage = \"\",\n    exportWithBackgroundImage = false,\n    preserveBackgroundImageAspectRatio = \"none\",\n    strokeWidth = 4,\n    eraserWidth = 8,\n    allowOnlyPointerType = \"all\",\n    style = {\n      border: \"0.0625rem solid lightgray\",\n      borderRadius: \"0.25rem\",\n    },\n    svgStyle = {},\n    onChange = (_paths: CanvasPath[]): void => undefined,\n    onStroke = (_path: CanvasPath, _isEraser: boolean): void => undefined,\n    withTimestamp = false,\n    invert = false,\n  } = props;\n\n  const strokeColor = React.useMemo(() => {\n    return `rgb(${strokeRed}, ${strokeGreen}, ${strokeBlue})`;\n  }, [strokeRed, strokeGreen, strokeBlue]);\n\n  const svgCanvas = React.createRef<CanvasRef>();\n  const [drawMode, setDrawMode] = React.useState<boolean>(true);\n  const [isDrawing, setIsDrawing] = React.useState<boolean>(false);\n  const [resetStack, setResetStack] = React.useState<CanvasPath[]>([]);\n  const [undoStack, setUndoStack] = React.useState<CanvasPath[]>([]);\n  const [currentPaths, setCurrentPaths] = React.useState<CanvasPath[]>([]);\n\n  const liftStrokeUp = React.useCallback((): void => {\n    const lastStroke = currentPaths.slice(-1)?.[0] ?? null;\n\n    if (lastStroke === null) {\n      return;\n    }\n\n    onStroke(lastStroke, !lastStroke.drawMode);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDrawing]);\n\n  React.useEffect(() => {\n    liftStrokeUp();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDrawing]);\n\n  React.useEffect(() => {\n    onChange(currentPaths);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPaths]);\n\n  React.useImperativeHandle(ref, () => ({\n    eraseMode: (erase: boolean): void => {\n      setDrawMode(!erase);\n    },\n    clearCanvas: (): void => {\n      setResetStack([...currentPaths]);\n      setCurrentPaths([]);\n    },\n    undo: (): void => {\n      // If there was a last reset then\n      if (resetStack.length !== 0) {\n        setCurrentPaths([...resetStack]);\n        setResetStack([]);\n\n        return;\n      }\n\n      setUndoStack((paths) => [...paths, ...currentPaths.slice(-1)]);\n      setCurrentPaths((paths) => paths.slice(0, -1));\n    },\n    redo: (): void => {\n      // Nothing to Redo\n      if (undoStack.length === 0) return;\n\n      setCurrentPaths((paths) => [...paths, ...undoStack.slice(-1)]);\n      setUndoStack((paths) => paths.slice(0, -1));\n    },\n    exportImage: (imageType: ExportImageType): Promise<string> => {\n      const exportImage = svgCanvas.current?.exportImage;\n\n      if (!exportImage) {\n        throw Error(\"Export function called before canvas loaded\");\n      } else {\n        return exportImage(imageType);\n      }\n    },\n    exportSvg: (): Promise<string> => {\n      return new Promise<string>((resolve, reject) => {\n        const exportSvg = svgCanvas.current?.exportSvg;\n\n        if (!exportSvg) {\n          reject(Error(\"Export function called before canvas loaded\"));\n        } else {\n          exportSvg()\n            .then((data) => {\n              resolve(data);\n            })\n            .catch((e) => {\n              reject(e);\n            });\n        }\n      });\n    },\n    exportPaths: (): Promise<CanvasPath[]> => {\n      return new Promise<CanvasPath[]>((resolve, reject) => {\n        try {\n          resolve(currentPaths);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    },\n    loadPaths: (paths: CanvasPath[]): void => {\n      setCurrentPaths((path) => [...path, ...paths]);\n    },\n    getSketchingTime: (): Promise<number> => {\n      return new Promise<number>((resolve, reject) => {\n        if (!withTimestamp) {\n          reject(new Error(\"Set 'withTimestamp' prop to get sketching time\"));\n        }\n\n        try {\n          const sketchingTime = currentPaths.reduce(\n            (totalSketchingTime, path) => {\n              const startTimestamp = path.startTimestamp ?? 0;\n              const endTimestamp = path.endTimestamp ?? 0;\n\n              return totalSketchingTime + (endTimestamp - startTimestamp);\n            },\n            0\n          );\n\n          resolve(sketchingTime);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    },\n    resetCanvas: (): void => {\n      setResetStack([]);\n      setUndoStack([]);\n      setCurrentPaths([]);\n    },\n  }));\n\n  const handlePointerDown = (point: Point, isEraser = false): void => {\n    setIsDrawing(true);\n    setUndoStack([]);\n\n    const isDraw = !isEraser && drawMode;\n\n    let stroke: CanvasPath = {\n      drawMode: isDraw,\n      strokeColor: isDraw ? strokeColor : \"#000000\", // Eraser using mask\n      strokeWidth: isDraw ? strokeWidth : eraserWidth,\n      paths: [point],\n    };\n\n    if (withTimestamp) {\n      stroke = {\n        ...stroke,\n        startTimestamp: Date.now(),\n        endTimestamp: 0,\n      };\n    }\n\n    setCurrentPaths((paths) => [...paths, stroke]);\n  };\n\n  const handlePointerMove = (point: Point): void => {\n    if (!isDrawing) return;\n\n    const currentStroke = currentPaths.slice(-1)[0];\n    const updatedStroke = {\n      ...currentStroke,\n      paths: [...currentStroke.paths, point],\n    };\n    setCurrentPaths((paths) => [...paths.slice(0, -1), updatedStroke]);\n  };\n\n  const handlePointerUp = (): void => {\n    if (!isDrawing) {\n      return;\n    }\n\n    setIsDrawing(false);\n\n    if (!withTimestamp) {\n      return;\n    }\n\n    const currentStroke = currentPaths.slice(-1)?.[0] ?? null;\n\n    if (currentStroke === null) {\n      return;\n    }\n\n    const updatedStroke = {\n      ...currentStroke,\n      endTimestamp: Date.now(),\n    };\n\n    setCurrentPaths((paths) => [...paths.slice(0, -1), updatedStroke]);\n  };\n\n  return (\n    <Canvas\n      ref={svgCanvas}\n      id={id}\n      width={width}\n      height={height}\n      className={className}\n      canvasColor={canvasColor}\n      strokeRed={strokeRed}\n      strokeGreen={strokeGreen}\n      strokeBlue={strokeBlue}\n      backgroundImage={backgroundImage}\n      exportWithBackgroundImage={exportWithBackgroundImage}\n      preserveBackgroundImageAspectRatio={preserveBackgroundImageAspectRatio}\n      allowOnlyPointerType={allowOnlyPointerType}\n      style={style}\n      svgStyle={svgStyle}\n      paths={currentPaths}\n      isDrawing={isDrawing}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      invert={invert}\n    />\n  );\n});\n"],"mappings":"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","names":["React","React"]}